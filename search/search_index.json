{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Batap Engine","text":""},{"location":"#build","title":"Build","text":""},{"location":"#requirements","title":"Requirements","text":"<p>Make sure you have the following installed before building:</p> <ul> <li>CMake \u2265 3.19</li> <li>Ninja (required for building with the presets)</li> <li>Visual Studio 2022 with \"Desktop development with C++\" workload </li> </ul>"},{"location":"#using-cmake-presets","title":"Using CMake Presets","text":"<p>This project includes a <code>CMakePresets.json</code> file, so you can build it easily:</p> <pre><code>build_msvc.bat &lt;preset-name&gt; [--configure]\n</code></pre> <ul> <li><code>&lt;preset-name&gt;</code> : name of the CMake preset to use (as defined in <code>CMakePresets.json</code>)<ul> <li><code>msvc-release</code></li> <li><code>msvc-debug</code></li> <li><code>msvc-relwithdebinfo</code></li> <li><code>msvc-debug-asan</code></li> </ul> </li> <li><code>--configure</code> : Forces a CMake reconfiguration before building. Use this on the first build or after changes to CMake files or source layout.</li> </ul> <p>VSCode users: build tasks are already defined in the <code>.vscode</code> folder.</p>"},{"location":"engine/","title":"Engine","text":""},{"location":"engine/#frame-life-cycle","title":"Frame Life Cycle","text":"<pre><code>Frame start\n\u2502\n\u251c\u2500 Async messages\n\u2502   \u2514\u2500 File dialog \u2192 asset import\n\u2502\n\u251c\u2500 Input\n\u2502   \u251c\u2500 Dispatch events\n\u2502   \u2514\u2500 Update input state\n\u2502\n\u251c\u2500 Simulation (CPU)\n\u2502   \u251c\u2500 Scene update (game logic)\n\u2502   \u2514\u2500 ECS systems update\n\u2502       \u2514\u2500 Update components &amp; mark components dirty for GPU\n\u2502\n\u251c\u2500 ECS \u2192 GPU sync\n\u2502   \u2514\u2500 Update GPU instances from dirty ECS data\n\u2502\n\u2514\u2500 Render\n</code></pre>"},{"location":"engine/#asset-manager","title":"Asset Manager","text":"<p>Purpose </p> <ul> <li>Manage asset lifetime on CPU  </li> <li>Bridge imported data and GPU resources  </li> </ul> <p>Properties</p> <ul> <li>Assets are data-only</li> <li>Assets are referenced, never owned, by instances</li> </ul> <p>Examples</p> <ul> <li>Mesh</li> <li>Texture</li> <li>Material data</li> </ul>"},{"location":"engine/#ecs","title":"ECS","text":"<p>Overview</p> <ul> <li>ECS stores authoritative CPU-side data</li> <li>Components represent state</li> <li>Systems implement logic</li> </ul> <p>Components</p> <ul> <li>Stored in <code>src/Components</code></li> <li>Ideally data-only (small helper logic allowed)</li> <li>Source of truth</li> <li>No direct GPU access</li> <li>Mutations must occur inside a System</li> <li>GPU-relevant writes outside systems must use <code>Scene::write&lt;Component&gt;()</code></li> <li>Direct <code>entt::registry::get / try_get</code> bypasses dirty tracking</li> </ul> <p>Systems</p> <ul> <li>Stored in <code>src/Systems</code></li> <li>Ideally pure logic</li> <li>Read/write components</li> <li>Mark components dirty when GPU sync is required</li> </ul> <p>Rules</p> <ul> <li>Systems do not access GPU resources</li> <li>Systems do not own data</li> <li>Systems operate only on ECS state</li> </ul>"},{"location":"engine/#gpu-instances-instance-manager-declaration","title":"GPU Instances / Instance Manager / Declaration","text":"<p>Instance Manager</p> <ul> <li>Owns multiple <code>FrameInstancePool&lt;T&gt;</code></li> <li>One pool per instance type (Camera, Mesh, ...)</li> </ul> <p>FrameInstancePool</p> <ul> <li>One structured GPU buffer + SRV per pool</li> <li>Contiguous CPU-side pool</li> <li>Entity \u2192 Instance mapping</li> <li>Supports resize and recycling</li> </ul>"},{"location":"engine/#gpu-instance","title":"GPU Instance","text":"<p>Purpose</p> <ul> <li>Represent ECS entities in a GPU-friendly format</li> <li>Synchronize ECS data to GPU buffers</li> <li>Support multi-frame-in-flight rendering</li> </ul> <p>Defines</p> <ul> <li>Used ECS components: <code>ComponentFlag UsedComposents</code></li> <li>GPU memory layout: <code>GPUData</code></li> <li>CPU \u2192 GPU fill rules: <code>InstancePatch</code></li> </ul> <p>Constraints</p> <ul> <li><code>GPUData</code> must be trivially copyable</li> <li>GPU-compatible alignment</li> <li>No pointers or ownership</li> <li>No direct GPU access</li> </ul>"},{"location":"renderer/","title":"Renderer","text":""},{"location":"renderer/#commandqueue","title":"CommandQueue","text":"<p>Purpose</p> <ul> <li>Own a DX12 command queue</li> <li>Manage a fixed set of command allocators and command lists</li> <li>Execute command lists and signal GPU fences</li> </ul> <p>Properties</p> <ul> <li>One queue per command list type</li> <li>One <code>Command</code> per frame-in-flight</li> <li>Each <code>Command</code> owns its allocator and command list</li> </ul>"},{"location":"renderer/#descriptorheapallocator","title":"DescriptorHeapAllocator","text":"<p>DX12 descriptor heap allocation and recycling.</p> <p>Purpose</p> <ul> <li>Own a DX12 descriptor heap</li> <li>Allocate and recycle descriptor slots</li> <li>Provide CPU/GPU descriptor handles</li> </ul> <p>Properties</p> <ul> <li>One allocator per descriptor heap type (CBV/SRV/UAV, Sampler)</li> <li>Fixed-capacity descriptor heap</li> <li>Linear allocation with free-list recycling</li> </ul> <p>DescriptorHandle</p> <ul> <li>One handle per allocated descriptor</li> <li>Stores heap index</li> <li>Stores CPU handle</li> <li>Stores GPU handle when shader-visible</li> </ul>"},{"location":"renderer/#fencemanager","title":"FenceManager","text":"<ul> <li>DX12 fence management and CPU/GPU synchronization.</li> </ul>"},{"location":"renderer/#resourcemanager","title":"ResourceManager","text":"<p>GPU resource + view lifetime on DX12. Creation, uploads, and deferred release.</p> <p>Purpose</p> <ul> <li>Create GPU buffers/textures (static or per-frame)</li> <li>Create GPU views (CBV/SRV/UAV/RTV/DSV) + mesh views (VBV/IBV)</li> <li>Upload CPU data to GPU via per-frame upload buffers</li> <li>Defer resource/view destruction until GPU is done</li> </ul> <p>Properties</p> <ul> <li>Static resources: Rarely changing resource</li> <li>Frame resources: Constantly changing. Duplicated for all frames in flight</li> <li>Views mirror resource lifetime (StaticView / FrameView)</li> <li>Per-frame <code>UploadBuffer</code> (UPLOAD heap, mapped CPU)</li> <li>One internal fence (<code>Fence_ResourceManager</code>) for upload/release sync</li> </ul> <p>Upload</p> <ul> <li><code>requestUpload()</code> queues external data pointer</li> <li><code>requestUploadOwned()</code> returns a writable span stored in the request</li> <li><code>flushUploadRequests()</code> uploads all queued requests then resets upload offset</li> </ul> <p>Descriptor heaps</p> <ul> <li>Owns 4 <code>DescriptorHeapAllocator</code>:</li> <li>CBV/SRV/UAV, Sampler, RTV, DSV</li> </ul> <p>Destruction</p> <ul> <li><code>requestDestroy()</code> removes from active maps and pushes into <code>_deferredReleases</code></li> <li><code>flushDeferredReleases()</code> stamps pending entries with a fence value and releases when complete</li> </ul>"},{"location":"renderer/#pipelinestatemanager","title":"PipelineStateManager","text":"<p>Purpose</p> <ul> <li>Create Root Signatures from a small description</li> <li>Create and cache PSOs (Graphics / Compute)</li> <li>Bind PSOs with redundant-bind avoidance</li> </ul> <p>Properties</p> <ul> <li>Stores PSOs and Shaders</li> <li>Root signature params:</li> <li>Descriptor table (<code>DescriptorTableDesc</code>)</li> <li>Root constants (<code>RootConstantsDesc</code>)</li> </ul> <p>exemple : creation of a 3D pipeline state</p> <pre><code>{\n        auto vs = _psoManager-&gt;compileShaderFromFile(\n            toS(\"shader_3D_VS\"), shader_dir + \"/VertexShader.hlsl\", \"main\", \"vs_5_1\");\n\n        auto ps = _psoManager-&gt;compileShaderFromFile(\n            toS(\"shader_3D_PS\"), shader_dir + \"/PixelShader.hlsl\", \"main\", \"ps_5_1\");\n\n        RootSignatureDescription rsDesc_VS{\n            {\n                DescriptorTableDesc{D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 0, 0,\n                                    D3D12_SHADER_VISIBILITY_ALL},            // Camera\n                DescriptorTableDesc{D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, 1, 0,\n                                    D3D12_SHADER_VISIBILITY_VERTEX},         // Mesh InstanceData\n                RootConstantsDesc{2, 0, 0, D3D12_SHADER_VISIBILITY_ALL}      // indices : Camera, Mesh\n            },\n            D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT};\n\n        D3D12_INPUT_ELEMENT_DESC layout[] = {\n            {\"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,\n             D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},\n            {\"NORMAL\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 1, 0,\n             D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},\n            {\"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT, 2, 0,\n             D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},\n        };\n\n        _psoManager-&gt;createGraphicsPipelineState(\n            \"geometry_pass\", rsDesc_VS,\n            [&amp;](D3D12_GRAPHICS_PIPELINE_STATE_DESC&amp; desc)\n            {\n                desc.InputLayout = {layout, _countof(layout)};\n                desc.VS = {vs-&gt;_blob-&gt;GetBufferPointer(), vs-&gt;_blob-&gt;GetBufferSize()};\n                desc.PS = {ps-&gt;_blob-&gt;GetBufferPointer(), ps-&gt;_blob-&gt;GetBufferSize()};\n                desc.DSVFormat = DXGI_FORMAT_D32_FLOAT;\n                desc.DepthStencilState.DepthEnable = 1;\n                desc.DepthStencilState.DepthFunc = D3D12_COMPARISON_FUNC_LESS;\n                desc.DepthStencilState.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;\n            });\n    }\n</code></pre>"},{"location":"renderer/#scenerenderer","title":"SceneRenderer","text":"<p>Decouples rendering from the Scene.</p> <p>Purpose</p> <ul> <li>Bind a <code>Scene</code> to the renderer side</li> <li>Define render passes for the current scene</li> <li>Trigger GPU instance uploads for dirty ECS data</li> </ul> <p>Properties</p> <ul> <li>Holds a <code>Scene*</code> (no ownership)</li> <li>Uses <code>Context</code> to access renderer, assets, and instance manager</li> <li>Passes are registered into the <code>RenderGraph</code></li> </ul> <p>Rules</p> <ul> <li>Scene logic stays in ECS systems, not here</li> <li>Only consumes ECS state to render (camera selection, mesh instances)</li> <li>Uploads go through <code>GPUInstanceManager</code> (per frame index)</li> </ul>"},{"location":"renderer/#rendergraph","title":"RenderGraph","text":"<p>Purpose</p> <ul> <li>Organize render passes</li> <li>Record and execute per frame-in-flight</li> </ul> <p>Properties</p> <ul> <li>Pass = list of record steps</li> <li>One command list per queue per frame</li> </ul>"}]}